function physio_cli_fmri(use_case, fmri_in, out_dir, correct, varargin)   
%% A command line wrapper for the main entry function 
% The main purpose of this script is integraton to CBRAIN yet it 
% can be used with other frameworks as well, or compilation so tool can be used
% on machine without MATLAB
%
% NOTE: All physio-structure can be specified previous to
%       running this function, e.g model.retroir.c, 3, save_dir - prefix
%       for resulting folder and in_dir are positional parameters, absent 
%        in the original physio.
%
% IN 
%   in_dir           Folder containing input data (logfiles and fMRI data)
%                    or fmri file for manual input
%   out_dir          Name of folder for outputs
%   use_case         Specifies what input directory structure to expect
%   correct          Choose whether to correct fMRI run or just produce
%                    regressors
%
% OUT
%   multiple_regressors.txt       File containing regressors generated by
%                                 PhysIO
%   *.png                         Diagnostic plots from PhysIO
%   fmri_corrected.nii            If 'correct' is set to 'yes', returns
%                                 corrected fMRI image
%   pct.var.reduced.nii           3D double representing the pct var
%                                 reduced by the regressors at each voxel
%
% EXAMPLES
%
%   physio_cli_fmri('input_folder',...
%                   'output_folder',...
%                   'Single_run',...
%                   'yes',...
%                   'param_1', 'value_1',...
%                   'param_2', 'value_2',...
%                   'param_3', 'value_3') 
%
%
% TODO:
%
%   Fix figure generation
%   Implement validation and error catching for input folder scanning
%   Add more physio format use cases
%   Allow for unzipped niftis as input
%
%
% REFERENCES
%
% CBRAIN        www.cbrain.com 
% RETROICOR     regressor creation based on Glover et al. 2000, MRM 44 and
%               Josephs et al. 1997, ISMRM 5, p. 1682
%               default model order based on Harvey et al. 2008, JMRI 28
% RVT           (Respiratory volume per time) Birn et al. 2008, NI 40
% HRV           (Heart-rate  variability) regressor creation based on
%               Chang et al2009, NI 44
%
% See also tapas_physio_new

% Authors:    Serge Boroday, Darius Valevicius
% Created:   2021-03-16
% Copyright: McGill University
%
%
% The original tool is by Institute for Biomedical Engineering, 
%               University of Zurich and ETH Zurich.
%
% This file is a wrapper for TAPAS PhysIO Toolbox


%SEPARATOR = '\s*[,\s]'; % the separator for vector/interval inputs - coma and/or white space
%DOT = '__'; % to use MATLAP argument parser the dots are replaced with doubleunderscore

% Diagnostic print output
% disp("PWD and work dir contents:");
% disp(pwd);
% disp(struct2table(dir()));

% Add PhysIO code to path (Does not work with compiler)
% addpath(genpath('code'));

%% Input Parser

p = inputParser;
p.KeepUnmatched = true;


addRequired(p, 'use_case');
%addParameter(p, 'in_dir', 'none');
% Not sure how this will work in tandem with boutiques. Setting all to
% required now, with optional params defaulting to 'none'.

addRequired(p, 'fmri_in');

addRequired(p, 'out_dir');

%addRequired(p, 'fmri_file');
%addParameter(p, 'fmri_file', 'none');

addRequired(p, 'correct');

parse(p, use_case, fmri_in, out_dir, correct);

% Debugging: display inputs

%input_msg = ['Use case: ',use_case,', In dir: ',in_dir,', Out dir: ',out_dir,', Fmri file: ',fmri_file,', Correct: ',correct];

%disp(input_msg);


%% Start diary

diary_file = fullfile(out_dir, 'derivatives', 'PhysIO', 'cbrain_physio.log');
disp(diary_file);
mkdir(fullfile(out_dir, 'derivatives', 'PhysIO'));

[fid, msg] = fopen(diary_file, 'w');
disp(msg);
fprintf(fid, 'Log of PhysIO on CBRAIN\n');
fprintf(fid, append(string(datetime('now','TimeZone','local','Format','d-MMM-y HH:mm:ss Z')), '\n'));
fclose(fid);
diary(diary_file);

%% Create default parameter structure with all fields
physio = tapas_physio_new();

physio = setDefaults(physio);

physio.correct = correct;

%% Set specified parameters (save_dir and varargin)

% disp(varargin);

varargin(1:2:end) = strrep(varargin(1:2:end), '.', '__');
try
    fields = [varargin(1:2:end); varargin(2:2:end)];
catch ME
   if (strcmp(ME.identifier,'MATLAB:catenate:dimensionMismatch'))
      msg = ['Varargin: Dimension mismatch occurred: First argument has ', ...
            num2str(size(varargin(1:2:end),2)),' columns while second has ', ...
            num2str(size(varargin(2:2:end),2)),' columns.'];
        causeException = MException('MATLAB:myCode:dimensions',msg);
        ME = addCause(ME,causeException);
   end
   rethrow(ME)
end 
    



% Set params in physio structure from varargin
for i = 1:size(fields, 2)
    
    field_value = fields{2, i};
    
    if (~isnan(str2double(field_value)))
        field_value = str2double(field_value);
    elseif (strcmp(field_value, 'yes') || strcmp(field_value, 'true'))
        field_value = 1;
    elseif (strcmp(field_value, 'no') || strcmp(field_value, 'false'))
        field_value = 0;
    end
    
    fieldseq = regexp(fields{1, i}, '__', 'split');
    physio = setfield(physio, fieldseq{:}, field_value);
end


%% Set fmri_file and in_dir values (hackey workaround to CBRAIN interface problem)
% Problem description: File type inputs in CBRAIN cannot have default
% values. Therefore they can't be passed as positional params, and have to
% be extracted from varargin.

% Update 17/01/2022:
% Merged fmri_file and in_dir inputs into single argument to facilitate
% output folder naming within the boutiques descriptor.

in_dir = 'none';
fmri_file = 'none';

switch use_case
    case 'bids_subject_folder'
        in_dir = fmri_in;
    case 'manual_input'
        fmri_file = fmri_in;
end


%% Scan subject directory and perform correction on each fMRI file

phys_ext = '';
%cardiac_marker = '';
%resp_marker = '';

switch physio.log_files.vendor
    case 'BIDS'
        phys_ext = '.tsv';
    case 'Philips'
        phys_ext = '.log';
end


switch use_case
    case 'bids_subject_folder'
        
        % From input/subject folder
        % Get every nifti in func
        % and associated physlogfiles
        % based on vendor
        %   BIDS: .tsv.gz
        %   Philips: .log
        %   
        % Currently implemented for BIDS and Philips only    

        if strcmp(in_dir, 'none')
            msg = 'BIDS scanning use-case requires input directory.';
            error(msg)
        end
        
        
        % Get all bold files
        bold_filelist = dir(fullfile(in_dir, '**/*bold.nii*'));
        % Get all physio files
        physio_filelist = dir(fullfile(in_dir, sprintf('**/*physio%s*', phys_ext)));
        
        % loop through bold files
        for i = 1:numel(bold_filelist)
            file = bold_filelist(i);
            filename = file.name;
            b_filepath = file.folder;
            
            fprintf('\n\nProcessing file: %s\n', filename);
            
            % set fmri file
            fmri_file = fullfile(b_filepath, filename);
            
            % get subject folder and session tokens
            subject_folder = append('sub-', extractBetween(filename, 'sub-', '_'));
            session = '';
            if contains(filename, '_ses-')
                session = append('ses-', extractBetween(filename, 'ses-', '_'));
            end
           
            % create save file name
            save_filename = insertBefore(filename, 'bold', 'corrected-physio_');
            % Get subject folder name
            % [~, bids_name, bids_ext] = fileparts(in_dir);
            %subject_folder = strcat(bids_name, bids_ext);
            % get folder name for diagnostic outputs
            %[~, fmri_name, ~] = fileparts(save_filename);
            fmri_name = extractBefore(save_filename, '.nii');
            physio.save_dir = fullfile(out_dir, 'derivatives', 'PhysIO', subject_folder, session, 'func', fmri_name);
            physio.save_dir_fmri = fullfile(out_dir, 'derivatives', 'PhysIO', subject_folder, session, 'func');
            % mkdir(physio.save_dir);
        
            % loop through physio files
            for j=1:numel(physio_filelist)
                p_file = physio_filelist(j);
                p_filename = p_file.name;
                p_filepath = p_file.folder;
                if contains(p_filename, extractBefore(filename, '_bold'))
                    logfile = fullfile(p_filepath, p_filename);
                end
                
            end
            
            [has_cardiac, has_resp] = has_cardiac_resp(physio.log_files.vendor, logfile);
            
            if has_cardiac
                physio.log_files.cardiac = logfile;
            end
            if has_resp
                physio.log_files.respiration = logfile;
            end
            
            
            % Refresh some params (they would stack otherwise)
            % NOTE: the fact that this is needed may signal that other
            % parameters may break/stack when physio is looped. Keep an eye out,
            % may need to recode
            physio.model.output_physio = 'physio.mat';
            physio.model.output_multiple_regressors = 'multiple_regressors.txt';
          
   
            
            physio_wrap(fmri_file, physio);

        end 
        
    case 'manual_input'
        
        % No fmri input error
        if (strcmp(fmri_file, 'none'))
            msg = 'Manual input: No fMRI file was input.';
            error(msg);
        end
        
        % No logfile input error
        % also handles combined input if individual carfiles are not given
        if (~isfile(physio.log_files.cardiac) && ~isfile(physio.log_files.respiration))
            try 
                isfile(physio.log_files.cardiac_respiration);
                physio.log_files.cardiac = physio.log_files.cardiac_respiration;
                physio.log_files.respiration = physio.log_files.cardiac_respiration;
            catch
                msg = append('Manual input: Log file(s) are invalid. Input at least one logfile.');
                error(msg);
            end
        end
            
        
        physio.save_dir = out_dir;
        
        physio_wrap(fmri_file, physio);
        
    otherwise
        msg = 'No valid use-case selected.';
        error(msg);
    
end

end

function physio_wrap(fmri_file, physio)
% Get fMRI dimensions
fmri_data = double(niftiread(string(fmri_file)));
nifti_header = niftiinfo(fmri_file);


disp('Getting dimensions...');
physio = get_dimensions(physio, nifti_header);


% physio.verbose.fig_output_file = append(fmri_file, '_fig_output.jpg');

% Run physio
% postpone figs
disp('Postponing figure generation...');
[physio, verbose_level, fig_output_file] = postpone_figures(physio);
%disp('fig name:');
%disp(fig_output_file);
% Run PhysIO
disp('Creating PhysIO regressors...');
physio = tapas_physio_main_create_regressors(physio);
disp('Complete.');

% generate figures without rendering
disp('Generating and saving figures...');
generate_figures(physio, verbose_level, fig_output_file);


% Run image correction
if(strcmpi(physio.correct, 'yes'))
    disp('Correcting fMRI data...');

    disp('Loading regressors...');
    % Load multiple regressors file
    regressors = load(fullfile(physio.save_dir, 'multiple_regressors.txt'));

    disp('Running Correction...');
    % Run correction
    % Correction algorithm adapted from Catie Chang

    disp('Arranging label...');
    % Arrange data label
    Y = reshape(fmri_data, physio.x_size*physio.y_size*physio.scan_timing.sqpar.Nslices, physio.scan_timing.sqpar.Nscans)';
    t = (1:physio.scan_timing.sqpar.Nscans)';

    disp('Setting up design matrix...');
    % Set design matrix
    % Uses intercept (1), time, time squared, and PhysIO regressors
    XX = [t, t.^2, regressors];
    XX = [ones(size(XX,1),1), zscore(XX)];

    disp('Regressing...');
    % Compute model betas and subtract beta-weighted regressors from input fmri
    % data to correct
    Betas = XX\Y;
    Y_corr = Y - XX(:,4:end)*Betas(4:end,:);

    disp('Correcting...');
    fmri_corrected = reshape(Y_corr', physio.x_size, physio.y_size, physio.scan_timing.sqpar.Nslices, physio.scan_timing.sqpar.Nscans);

    disp('Computing pct var reduced...');
    % Compute pct var reduced (3D double)
    %disp('Get raw fmri variance');
    var_raw = var(fmri_data, 0, 4);
    %disp('Get corrected fmri variance');
    var_corrected = var(fmri_corrected, 0, 4);
    %disp('Get difference in variance');
    pct_var_reduced = (var_raw - var_corrected) ./ var_raw;
    %disp('Finished function');
    %disp('Creating Mask...')
    %mask = createMask(fmri_data);
    % niftiwrite(mask, 'mask_test.nii');
    %pct_var_reduced = pct_var_reduced .* mask;

    disp('Correction complete.');
    fprintf('Maximum variance reduced(diagnostic): %d\n', max(pct_var_reduced, [], 'all'));

    disp('Typecasting data...');
    data_type = nifti_header.Datatype;
    fmri_corrected_typecast = cast(fmri_corrected(:), data_type);
    fmri_corrected_typecast = reshape(fmri_corrected_typecast, size(fmri_corrected));

    disp('Writing niftis...');
    
    fmri_corrected_filename = create_output_filename(physio, fmri_file);
    fmri_corrected_fullfile = string(fullfile(physio.save_dir_fmri, fmri_corrected_filename));
    % disp(fmri_corrected_fullfile);
    
    niftiwrite(fmri_corrected_typecast, fmri_corrected_fullfile, nifti_header);
    niftiwrite(pct_var_reduced, fullfile(physio.save_dir, 'pct_var_reduced.nii'));
    %gzip(strcat(physio.save_dir, '/fmri_corrected.nii'));
    disp('Compressing...');
    gzip(fmri_corrected_fullfile);
    delete(fmri_corrected_fullfile);

    disp('Complete.');
end


% Get HR and BR
write_hr_br(physio)
    
    

end

function fmri_corrected_filename = create_output_filename(physio, fmri_file)
% Create output files
    [~,fmri_name_only,ext] = fileparts(fmri_file);
    if contains(fmri_name_only, '_bold.nii')
        fmri_name_models = extractBefore(append(fmri_name_only, ext), '_bold.nii');
    else
        fmri_name_models = extractBefore(append(fmri_name_only, ext), '.nii');
    end

    fmri_name_models = append(fmri_name_models, '_corrected');

    % Append model names
    if physio.model.retroicor.include
        fmri_name_models = append(fmri_name_models, '-retroicor');
    end
    if physio.model.rvt.include
        fmri_name_models = append(fmri_name_models, '-rvt');
    end
    if physio.model.hrv.include
        fmri_name_models = append(fmri_name_models, '-hrv');
    end
    if physio.model.noise_rois.include
        fmri_name_models = append(fmri_name_models, '-noiseRois');
    end
    if physio.model.movement.include
        fmri_name_models = append(fmri_name_models, '-movement');
    end

    fmri_corrected_filename = append(fmri_name_models, '_bold.nii');
end

function physio = get_dimensions(physio, nifti_header)
% Get fmri file dimenions from header

physio.x_size = nifti_header.ImageSize(1);
physio.y_size = nifti_header.ImageSize(2);
physio.scan_timing.sqpar.Nslices = nifti_header.ImageSize(3);
physio.scan_timing.sqpar.Nscans = nifti_header.ImageSize(4);
physio.scan_timing.sqpar.TR = nifti_header.PixelDimensions(4);
if strcmp(physio.scan_timing.sqpar.onset_slice, '<UNDEFINED>')
    physio.scan_timing.sqpar.onset_slice = physio.scan_timing.sqpar.Nslices / 2;
end

end

function write_hr_br(physio)
[heartrate_hertz, heartrate_bpm, breathing_hertz, breathing_bpm] = get_hr_br(physio);
t = table(heartrate_hertz, heartrate_bpm, breathing_hertz, breathing_bpm);
writetable(t, fullfile(physio.save_dir, 'hr_br.txt'), 'Delimiter', '\t');
end




function [physio, verbose_level, fig_output_file] = postpone_figures(physio)

% postpone figure generation in first run - helps with compilation
% relies on certain physio.verbose parameters - see setDefaults() below
if isfield(physio, 'verbose') && isfield(physio.verbose, 'level')
     verbose_level = physio.verbose.level;
     physio.verbose.level = 0;
     if isfield(physio.verbose, 'fig_output_file') && ~strcmp(physio.verbose.fig_output_file, '')
         fig_output_file = physio.verbose.fig_output_file;
     else
         fig_output_file = 'PhysIO_output.jpg'; 
     end    
else
  verbose_level = 0;
end 

end

function generate_figures(physio, verbose_level, fig_output_file)

% Build figures
if verbose_level
  physio.verbose.fig_output_file = fig_output_file; % has to reset, the old value is distorted
  physio.verbose.level = verbose_level;
  tapas_physio_review(physio);
end

end


function [has_cardiac, has_resp] = has_cardiac_resp(vendor, physlogfile)

%disp('starting has cardiac resp');

has_cardiac = 0;
has_resp = 0;

switch vendor
    case 'BIDS'
        
        header = get_bids_physlogfile_sidecar(physlogfile);
        
        % disp(header.Columns);

        if any(strcmp(header.Columns, 'cardiac'))
            %disp('has cardiac');
            has_cardiac = 1;
        end
        if any(strcmp(header.Columns, 'respiratory'))
            %disp('has resp');
            has_resp = 1;
        end
        
    case 'Philips'
        
        logfile = read_philips_physlogfile(physlogfile);
        
        if any(strcmp(logfile.Properties.VariableNames, 'ppu'))
            %disp('has cardiac');
            has_cardiac = 1;
        end
        if any(strcmp(logfile.Properties.VariableNames, 'resp'))
            %disp('has resp');
            has_resp = 1;
        end
    otherwise
        msg = append('BIDS subject folder mode does not work with vendor ', vendor);
        error(msg);
end

        
end


function [physio] = setDefaults(physio)
% PhysIO defaults as specified by PhysIO's 'template_matlab_script.m'
% <UNDEFINED> parameters must have an input!
% with the exception of cardiac and resp logfiles, if they are set not
% to be used

physio.save_dir = {'physio_out'};
physio.log_files.vendor = 'Philips';
%physio.log_files.cardiac = '<UNDEFINED>';
%physio.log_files.respiration = '<UNDEFINED>';
physio.log_files.relative_start_acquisition = 0;
physio.log_files.align_scan = 'last';
physio.scan_timing.sqpar.Nslices = '<UNDEFINED>';
physio.scan_timing.sqpar.TR = '<UNDEFINED>';
physio.scan_timing.sqpar.Ndummies = 0; % Changed from template
physio.scan_timing.sqpar.Nscans = '<UNDEFINED>';
physio.scan_timing.sqpar.onset_slice = '<UNDEFINED>';
physio.scan_timing.sync.method = 'nominal';
physio.preproc.cardiac.modality = 'ECG';
physio.preproc.cardiac.filter.include = false;
physio.preproc.cardiac.filter.type = 'butter';
physio.preproc.cardiac.filter.passband = [0.3 9];
physio.preproc.cardiac.initial_cpulse_select.method = 'auto_matched';
physio.preproc.cardiac.initial_cpulse_select.max_heart_rate_bpm = 90;
physio.preproc.cardiac.initial_cpulse_select.file = 'initial_cpulse_kRpeakfile.mat';
physio.preproc.cardiac.initial_cpulse_select.min = 0.4;
physio.preproc.cardiac.posthoc_cpulse_select.method = 'off';
physio.preproc.cardiac.posthoc_cpulse_select.percentile = 80;
physio.preproc.cardiac.posthoc_cpulse_select.upper_thresh = 60;
physio.preproc.cardiac.posthoc_cpulse_select.lower_thresh = 60;
physio.model.orthogonalise = 'none';
physio.model.censor_unreliable_recording_intervals = false;
physio.model.output_multiple_regressors = 'multiple_regressors.txt';
physio.model.output_physio = 'physio.mat';
physio.model.retroicor.include = true;
physio.model.retroicor.order.c = 3;
physio.model.retroicor.order.r = 4;
physio.model.retroicor.order.cr = 1;
physio.model.rvt.include = false;
physio.model.rvt.delays = 0;
physio.model.hrv.include = false;
physio.model.hrv.delays = 0;
physio.model.noise_rois.include = false;
physio.model.noise_rois.thresholds = 0.9;
physio.model.noise_rois.n_voxel_crop = 0;
physio.model.noise_rois.n_components = 1;
physio.model.noise_rois.force_coregister = 1;
physio.model.movement.include = false;
physio.model.movement.order = 6;
physio.model.movement.censoring_threshold = 0.5;
physio.model.movement.censoring_method = 'FD';
physio.model.other.include = false;
physio.verbose.level = 2;
physio.verbose.process_log = cell(0, 1);
physio.verbose.fig_handles = zeros(1, 0);
physio.verbose.use_tabs = false;
physio.verbose.show_figs = false; % Changed from templates
physio.verbose.save_figs = true; % Changed from template
physio.verbose.close_figs = true; % Changed from template
physio.ons_secs.c_scaling = 1;
physio.ons_secs.r_scaling = 1;

end


