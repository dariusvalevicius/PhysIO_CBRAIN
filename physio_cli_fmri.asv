function physio_cli_fmri(in_dir, out_dir, use_case, correct, varargin)   
%% A command line wrapper for the main entry function 
% The main purpose of this script is integraton to CBRAIN yet it 
% can be used with other frameworks as well, or compilation so tool can be used
% on machine without MATLAB
%
% NOTE: All physio-structure can be specified previous to
%       running this function, e.g model.retroir.c, 3, save_dir - prefix
%       for resulting folder and in_dir are positional parameters, absent 
%        in the original physio.
%
% IN 
%   in_dir           Folder containing input data (logfiles and fMRI data)
%   out_dir          Name of folder for outputs
%   use_case         Specifies what input directory structure to expect
%   correct          Choose whether to correct fMRI run or just produce
%                    regressors
%
% OUT
%   multiple_regressors.txt       File containing regressors generated by
%                                 PhysIO
%   *.png                         Diagnostic plots from PhysIO
%   fmri_corrected.nii            If 'correct' is set to 'yes', returns
%                                 corrected fMRI image
%   pct.var.reduced.nii           3D double representing the pct var
%                                 reduced by the regressors at each voxel
%
% EXAMPLES
%
%   physio_cli_fmri('input_folder',...
%                   'output_folder',...
%                   'Single_run',...
%                   'yes',...
%                   'param_1', 'value_1',...
%                   'param_2', 'value_2',...
%                   'param_3', 'value_3') 
%
%
% TODO:
%
%   Fix figure generation
%   Implement validation and error catching for input folder scanning
%   Add more physio format use cases
%   Allow for unzipped niftis as input
%
%
% REFERENCES
%
% CBRAIN        www.cbrain.com 
% RETROICOR     regressor creation based on Glover et al. 2000, MRM 44 and
%               Josephs et al. 1997, ISMRM 5, p. 1682
%               default model order based on Harvey et al. 2008, JMRI 28
% RVT           (Respiratory volume per time) Birn et al. 2008, NI 40
% HRV           (Heart-rate  variability) regressor creation based on
%               Chang et al2009, NI 44
%
% See also tapas_physio_new

% Author:    Serge Boroday
% Created:   2021-03-16
% Copyright: McGill University
%
% Modified by:  Darius Valevicius
% Date:         2021-06-22
%
% The original tool is by Institute for Biomedical Engineering, 
%               University of Zurich and ETH Zurich.
%
% This file is a wrapper for TAPAS PhysIO Toolbox


%SEPARATOR = '\s*[,\s]'; % the separator for vector/interval inputs - coma and/or white space
%DOT = '__'; % to use MATLAP argument parser the dots are replaced with doubleunderscore

% Diagnostic print output
%disp(pwd);
%disp(struct2table(dir()));

% Add PhysIO code to path (Does not work with compiler)
% addpath(genpath('code'));

%% Input Parser

p = inputParser;
p.KeepUnmatched = true;

addRequired(p, 'in_dir');
addRequired(p, 'out_dir');

addRequired(p, 'use_case');

%fmri_data = fullfile(in_dir, fmri_data);
%addRequired(p, 'fmri_data');   %, @isfile);
addRequired(p, 'correct');

parse(p, in_dir, out_dir, use_case, correct);


%% Create default parameter structure with all fields
physio = tapas_physio_new();

physio = setDefaults(physio);

%% Set specified parameters (save_dir and varargin)

varargin(1:2:end) = strrep(varargin(1:2:end), '.', '__'); 
fields = [varargin(1:2:end); varargin(2:2:end)];


% Set params in physio structure from varargin
for i = 1:size(fields, 2)
    
    field_value = fields{2, i};
    
    if (~isnan(str2double(field_value)))
        field_value = str2double(field_value);
    elseif (strcmp(field_value, 'yes') || strcmp(field_value, 'true'))
        field_value = 1;
    elseif (strcmp(field_value, 'no') || strcmp(field_value, 'false'))
        field_value = 0;
    end
    
    fieldseq = regexp(fields{1, i}, '__', 'split');
    physio = setfield(physio, fieldseq{:}, field_value);
end


%% postpone figure generation in first run - helps with compilation

if isfield(physio, 'verbose') && isfield(physio.verbose, 'level')
     verbose_level = physio.verbose.level;
     physio.verbose.level = 0;
     if isfield(physio, 'fig_output_file')
         fig_output_file = physio.verbose.fig_output_file;
     else
         fig_output_file = 'PhysIO_output.png'; 
     end    
else
  verbose_level = 0;
end 



%% Scan subject directory and perform correction on each fMRI file


% Set physlogfile suffix based on vendor
vendor = physio.log_files.vendor;

phys_suffix = '';

switch vendor
    case 'BIDS'
        phys_suffix = '.tsv.gz';
    case 'Philips'
        phys_suffix = '.log';
    case 'Biopac_Txt'
        phys_suffix = '.txt';
    case 'Biopac_Mat'
        phys_suffix = '.mat';
    case 'BrainProducts'
        phys_suffix = '.eeg';
    case 'Custom'
        phys_suffix = '.txt';
        % This one will not work until I write code for multiple physio files
        % to be found (one for cardiac and one for resp)
end



if strcmp(use_case, 'BIDS_subject_folder')

        % From input/subject folder
        % Get every nifti in func
        % and associated physlogfiles
        % based on vendor
        %   BIDS: .tsv.gz
        %   Philips: .log
        %   
        % Currently implemented for BIDS and Philips only    

    % Get session directories

    subject_folder = in_dir;
    sessions = dir(subject_folder);
    sessions = {sessions(3:end).name};

    disp('Iterating through fMRI files in subject folder.');
    
    % Iterate through sessions
    for s = sessions

        % Get all files in func directory
        func = dir(fullfile(subject_folder, s{:}, 'func'));
        func = {func(3:end).name};

        % Get fMRI files
        fmri_files = func(contains(func, '.nii.gz'));

        % For every fMRI file
        % Try to find corresponding physio logfile
        % Corresponding to run #
        % Set PhysIO parameters and run PhysIO

        for j = fmri_files

            disp(append('Correcting: ', j{:}))
            
            % Get run number            
            if contains(j, 'run-')
                run_num = extractAfter(j, 'run-');
                run_num = run_num{:}(1);
            else
                disp('This fMRI file does not correspond to a run. Skipping.')
                disp('Make sure that fMRI files contain the regular expression *run*.nii.gz');
                continue;
            end
            

            % Find logfile with run number

            wildcard = append('.*run-', run_num, '.*', phys_suffix);
            
            index = regexp(func, wildcard);

            logfile = string(func(~cellfun(@isempty, index)));

            % Set PhysIO params

            save_foldername = append(extractBefore(j, '.nii.gz'), '_physio_results');

            % Unzip and set fmri param
            fmri_filename = string(fullfile(subject_folder, s, 'func', j));

            % Set save dir and logfile params
            physio.save_dir = fullfile(out_dir, save_foldername);

            logfile = fullfile(subject_folder, s, 'func', logfile);
            physio.log_files.cardiac = logfile;
            physio.log_files.respiration = logfile;

            % Refresh some params (they would stack otherwise)
            % NOTE: the fact that this is needed may signal that other
            % parameters may break/stack when physio is looped. Keep an eye out,
            % may need to recode
            physio.model.output_physio = 'physio.mat';
            physio.model.output_multiple_regressors = 'multiple_regressors.txt';

            % Get fMRI dimensions
            fmri_j = double(niftiread(string(fmri_filename)));
            sz = size(fmri_j);
            Nslices = sz(3);
            Nframes = sz(4);

            physio.scan_timing.sqpar.Nslices = Nslices;
            physio.scan_timing.sqpar.Nscans = Nframes;
            
            % Figure out what is going on with these figs!!
            physio.verbose.level = 0;

            % Run PhysIO
            physio = run_physio(physio, verbose_level, fig_output_file);

            % Run image correction
            if(strcmpi(correct, 'yes'))
                performCorrection(fmri_filename, fmri_j, physio);
            end

        end

    end

elseif strcmp(use_case, 'Single_run')
    
    
    % Find fMRI file in input folder
    file_inputs = dir(in_dir);
    file_inputs = {file_inputs(3:end).name};

    fmri_filename = string(file_inputs(contains(file_inputs, '.nii.gz')));

    
    % Find logfile
    logfile = string(file_inputs(contains(file_inputs, phys_suffix)));
    
    
    % Set PhysIO params
    
    save_foldername = append(extractBefore(fmri_filename, '.nii.gz'), '_physio_results');
    
    % Unzip and set fmri param
    fmri_filename = fullfile(in_dir, fmri_filename);
    
    % Set save dir and logfile params
    physio.save_dir = fullfile(out_dir, save_foldername);
    
    logfile = fullfile(in_dir, logfile);
    physio.log_files.cardiac = logfile;
    physio.log_files.respiration = logfile;
    
    
    % Get fMRI dimensions
    fmri_data = double(niftiread(string(fmri_filename)));
    sz = size(fmri_data);
    Nslices = sz(3);
    Nframes = sz(4);
    
    physio.scan_timing.sqpar.Nslices = Nslices;
    physio.scan_timing.sqpar.Nscans = Nframes;
    
    % Run PhysIO
    physio = run_physio(physio, verbose_level, fig_output_file);
    
    % Run image correction
    if(strcmpi(correct, 'yes'))
        performCorrection(fmri_filename, fmri_data, physio);
    end
    
    
end


end


function [physio] = run_physio(physio, verbose_level, fig_output_file)

% Run physiological recording preprocessing and noise modeling

disp('Creating PhysIO regressors...');
physio = tapas_physio_main_create_regressors(physio);
disp('Complete.');

disp('Building figures...');
% Build figures
if verbose_level
    physio.verbose.fig_output_file = fig_output_file; % has to reset, the old value is distorted
    physio.verbose.level = verbose_level;
    % Suspending for now
    %tapas_physio_review(physio);
end
disp('Complete.');

end

function [S] = merge_struct(S_1, S_2)
% update the first struct with values and keys of the second and returns the result
% deep update, merges substructrues recursively, the values from the first
% coinside

f = fieldnames(S_2);

for i = 1:length(f)
    if isfield(S_1, f{i}) && isstruct(S_1.(f{i})) && isstruct(S_2.(f{i}))
        S_1.(f{i}) = merge_struct(S_1.(f{i}), S_2.(f{i}));
    else   
        S_1.(f{i}) = S_2.(f{i});
    end        
end
S = S_1;
end


function performCorrection(fmri_filename, fmri_data, physio)


    disp('Correcting fMRI data...');

    disp('Loading regressors...');
    % Load multiple regressors file
    regressors = load(fullfile(physio.save_dir, 'multiple_regressors.txt'));

    disp('Running Correction...');
    % Run correction
    [fmri_corrected, pct_var_reduced] = correct_fmri(fmri_data, regressors);

    disp('Correction complete.');
    fprintf('Maximum variance reduced(diagnostic): %d\n', max(pct_var_reduced, [], 'all'));

    disp('Writing niftis...');

    % Create output files
    [~,fmri_name_only,ext] = fileparts(fmri_filename);
    fmri_name_only = extractBefore(append(fmri_name_only, ext), '.nii.gz');
    fmri_corrected_filename = append(fmri_name_only, '_corrected.nii');
    
    niftiwrite(fmri_corrected, fullfile(physio.save_dir, fmri_corrected_filename));
    niftiwrite(pct_var_reduced, fullfile(physio.save_dir, 'pct_var_reduced.nii'));
    %gzip(strcat(physio.save_dir, '/fmri_corrected.nii'));

    disp('Complete.');


end

function [fmri_corrected, pct_var_reduced] = correct_fmri(fmri_data, regressors)
% Correction algorithm adapted from Catie Chang

disp('Getting dimensions...');
% Get dimensions
x = size(fmri_data);
nslices = x(3);
nframes = x(4);

disp('Arranging label...');
% Arrange data label
Y = reshape(fmri_data, x(1)*x(2)*nslices, nframes)';
t = (1:nframes)';

disp('Setting up design matrix...');
% Set design matrix
% Uses intercept (1), time, time squared, and PhysIO regressors
XX = [t, t.^2, regressors];
XX = [ones(size(XX,1),1), zscore(XX)];

disp('Regressing...');
% Compute model betas and subtract beta-weighted regressors from input fmri
% data to correct
Betas = XX\Y;
Y_corr = Y - XX(:,4:end)*Betas(4:end,:);

disp('Correcting...');
fmri_corrected = reshape(Y_corr', x(1), x(2), nslices, nframes);

disp('Computing pct var reduced...');
% Compute pct var reduced (3D double)
disp('Get raw fmri variance');
disp(x);
var_raw = var(fmri_data, 0, 4);
disp('Get corrected fmri variance');
disp(size(fmri_corrected));
var_corrected = var(fmri_corrected, 0, 4);
disp('Get difference in variance');
pct_var_reduced = (var_raw - var_corrected) ./ var_raw;

disp('Creating Mask...')
mask = createMask(fmri_data);
% niftiwrite(mask, 'mask_test.nii');
pct_var_reduced = pct_var_reduced .* mask;


end

function [mask] = createMask(fmri_data)
% Quick and dirty whole-brain masking function (not very good)
% Sets to zero all voxels whose average activation is less than 80% of the
% grand mean

disp('Applying mask...')
fmri_avg = mean(fmri_data, 4);
fmri_grand_mean = mean(fmri_avg, 'all');

mask = ones(size(fmri_avg));

mask(fmri_avg < (0.8 * fmri_grand_mean)) = 0;
disp('Complete.')

end


function [physio] = setDefaults(physio)
% PhysIO defaults as specified by PhysIO's 'template_matlab_script.m'
% <UNDEFINED> parameters must have an input!
% with the exception of cardiac and resp logfiles, if they are set not
% to be used

physio.save_dir = {'physio_out'};
physio.log_files.vendor = 'Philips';
physio.log_files.cardiac = '<UNDEFINED>';
physio.log_files.respiration = '<UNDEFINED>';
physio.log_files.relative_start_acquisition = 0;
physio.log_files.align_scan = 'last';
physio.scan_timing.sqpar.Nslices = '<UNDEFINED>';
physio.scan_timing.sqpar.TR = '<UNDEFINED>';
physio.scan_timing.sqpar.Ndummies = '<UNDEFINED>';
physio.scan_timing.sqpar.Nscans = '<UNDEFINED>';
physio.scan_timing.sqpar.onset_slice = '<UNDEFINED>';
physio.scan_timing.sync.method = 'nominal';
physio.preproc.cardiac.modality = 'ECG';
physio.preproc.cardiac.filter.include = false;
physio.preproc.cardiac.filter.type = 'butter';
physio.preproc.cardiac.filter.passband = [0.3 9];
physio.preproc.cardiac.initial_cpulse_select.method = 'auto_matched';
physio.preproc.cardiac.initial_cpulse_select.max_heart_rate_bpm = 90;
physio.preproc.cardiac.initial_cpulse_select.file = 'initial_cpulse_kRpeakfile.mat';
physio.preproc.cardiac.initial_cpulse_select.min = 0.4;
physio.preproc.cardiac.posthoc_cpulse_select.method = 'off';
physio.preproc.cardiac.posthoc_cpulse_select.percentile = 80;
physio.preproc.cardiac.posthoc_cpulse_select.upper_thresh = 60;
physio.preproc.cardiac.posthoc_cpulse_select.lower_thresh = 60;
physio.model.orthogonalise = 'none';
physio.model.censor_unreliable_recording_intervals = false;
physio.model.output_multiple_regressors = 'multiple_regressors.txt';
physio.model.output_physio = 'physio.mat';
physio.model.retroicor.include = true;
physio.model.retroicor.order.c = 3;
physio.model.retroicor.order.r = 4;
physio.model.retroicor.order.cr = 1;
physio.model.rvt.include = false;
physio.model.rvt.delays = 0;
physio.model.hrv.include = false;
physio.model.hrv.delays = 0;
physio.model.noise_rois.include = false;
physio.model.noise_rois.thresholds = 0.9;
physio.model.noise_rois.n_voxel_crop = 0;
physio.model.noise_rois.n_components = 1;
physio.model.noise_rois.force_coregister = 1;
physio.model.movement.include = false;
physio.model.movement.order = 6;
physio.model.movement.censoring_threshold = 0.5;
physio.model.movement.censoring_method = 'FD';
physio.model.other.include = false;
physio.verbose.level = 2;
physio.verbose.process_log = cell(0, 1);
physio.verbose.fig_handles = zeros(1, 0);
physio.verbose.use_tabs = false;
physio.verbose.show_figs = true;
physio.verbose.save_figs = false;
physio.verbose.close_figs = false;
physio.ons_secs.c_scaling = 1;
physio.ons_secs.r_scaling = 1;

end


